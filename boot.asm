; ============================================ REAL MODE =======================================================
use16               ; generate 16-bit code
org 7C00h           ; the code starts at 0x7C00 memory address

start:
    ; Используется дальний переход что бы записать явно в селектор кода значение 
    ; нулевого адреса(начало сегмента) и смещение (enrt)
    jmp far dword 0x0000:entr ; makes CS=0, IP=0x7c00
entr:
    
    ; Устанавливаем для сегментных регистров значение. В данном случае ds и ss имеют значение 0
    ; а регистр указателя на вершину стека указывает на начало программы
    xor  ax, ax     ; ax = 0
    mov  ds, ax     ; setup data segment ds=ax=0
    ; Во время настроика стека запрещаем прерывания, так как стек может быть не в валидном состоянии и 
    ; не может сохранять контексты программ (а они нужны для осуществления механизма прерываний)
    cli             ; when we set up stack we need disable interrupts because stack is involved in interrupts handling
    mov  ss, ax     ; setup stack segment ss=ax=0
    mov  sp, 0x7C00 ; stack will grow starting from 0x7C00 memory address
    ; Снова разрешаем прерывания, мы настроили уже к этому моменту стек 
    sti             ; enable interrupts
   
    ; Clear screen
    mov ax, 0x0003  ; ah=0 means clear screen and setup video mode, al=3 means text mode, 80x25 screen, CGA/EGA adapter, etc.
    int 0x10        ; call BIOS standard video service function
   
    ; Процессоры Intel 8086, 8088, 80186, выпускавшиеся в конце 70-х — начале 80-х годов 20-го века, 
    ; имели 20-разрядную шину адреса (т. н. существовали линии адреса A0-A19), что позволяло имя адресовать 
    ; до 1 MiB памяти. При этом использовалась сегментная адресация памяти, т. е. физический адрес вычислялся как
    ; сумма seg*16 + offset, где seg — 16-разрядный сегментный регистр, а offset — 16-разрядное смещение. Такой способ
    ; адресации теоретически позволял залезть в адресное пространство выше, чем 1 MiB 
    ; (например, если seg=0xFFFF и offset=0xFFFF, то 0xFFFF*0x10 + 0xFFFF = 0x10FFEF), однако отсутствие 20-й линии
    ; адреса приводило к так называемому свертыванию (wrap around) адреса (например, если seg=0xFFFF и offset=0xFFFF,
    ; то физический адрес = 0xFFFF*0x10 + 0xFFFF - 0x100000 = 0xFFEF).
    ; Но в 1982 году вышел процессор 80286 с 24-разрядной шиной адреса с возможностью адресации до 16 MiB памяти в 
    ; защищенном режиме (да, защищенный режим появился именно тогда). И в этом процессоре была допущена ошибка: 
    ; в реальном режиме он не обнулял принудительно линию адреса A20, что привело к устранению эффекта свертывания
    ; адреса, которым пользовались ранее некоторые программы в ОС DOS. Intel решили проблему путем ввода 
    ; на материнскую плату логического вентиля под названием «A20», который мог либо разрешить, либо 
    ; запретить (занулить) линию адреса A20. Программирование вентиля изначально осуществлялось через контроллер
    ; клавиатуры Intel 8042, сейчас существуют и другие способы, например, System Control Port A.
    ; Open gate A20 through the System Control Port A
    in  al, 0x92    ; read the content of port 0x92 (System Control Port A) into al
    or  al, 0x02    ; set 1st bit in al to 1
    out 0x92, al    ; write al into port 0x92


    ; В защищенном режиме механизм обработки прерываний иначе чем в защищенном. Операционка должна создать
    ; специальную стурктуру IDT(Interant Descriptor Table) в которой записываются дескрипторы которые описывают
    ; по какому мету находится обработчик прерывания. Данную таблицу мы  сдесь не создаем и поэтому обрабатывать
    ; корректно прерывания мы не сможем. Если произойдет прерывание и таблицы прерываний не будет то процессор
    ; сгенерирует исключение (зависнит или перезагрузится). Что бы такого не происходило мы запрещаем прерывания, а
    ; так же деактивируем маску маскируемых прерываний (прерывания бывают маскируемые и не маскируемые).
    ; Маскируемые прерывания - прерывания на которые процессор не будет реагировать если они замаскированы.
    ; Disable maskable interrupts
    cli ; clear flag IF in EFLAGS register
    ; Disable non-maskable interrupts
    in  al, 0x70
    or  al, 0x80
    out 0x70, al
   
    
    ; ================================= Осноаная работа по переходу в защищенный режим ==================================
    
    ; Тут происходит загрузка GDT(Global Descriptor Table) в специальный регист GDTR
    ; Записями в данной таблице являются так называемые дескрипторы, которые описывают сегменты памяти.
    ; В защищенном режиме используется немного иной механизм трансляции адресов нежеле в реальном режиме.
    ; Логический адрес как и прежде состоит из двух частей selector(base) : offset но в отлиции от реального режима
    ; в селекторе содержится не сам адрес, а индек указывающий в таблице на дескриптор, в поле которго и нахоится
    ; base (начало сегмента памяти) + некоторая информация для организации безопасности (уровни доступа).
    lgdt [gdtr]     ; load the address and size of Global Descriptor Table (GDT) into GDTR register
    
    ; Для того что бы перейти в защищенный режим достаточно просто установить(значение 1) первый бит специального регистра cr0.
    ; Этот бит называется PE (Protection Enable).
    ; Но этого мало для корректной работы процессора. Как мы уже упоминали, в защищенном режиме адресация происходит с использование селекторов.
    ; Эти селекторы будут содржать base(начало каждого сегмента памяти), которые будут браться из специальной таблицы (GDT/LDT). Собственно если
    ; данная таблица не сформированна будет сгенерированно исключение, которе мы не сможем обработать, так как у нас тоже нету таблицы обработчиков
    ; исключения (IDT). Сотвественно, нужно побготовить таблицу дескрипторов и загрузить ее в регистр GDTR что мы и сделали на предыдущем шаге.
    ; Switch to protected mode
    mov  eax, cr0   ; read the content of register cr0 (Machine Status Word - MSW) into eax
    or   al,  0x01  ; set 0th bit to 1 (0th bit of cr0 is called PE - Protection Enable)
    mov  cr0, eax   ; write eax to cr0

    ; Хочу обратить ваше внимание на то, что первой командой после перехода в 
    ; защищённый режим должна быть команда дальнего перехода (far jump), в 
    ; которой будет указан селектор дескриптора сегмента кода и смещение в 
    ; этом сегменте. При работе в защищённом режиме процессор может 
    ; использовать в сегментных регистрах только селекторы существующих 
    ; дескрипторов, любые другие значения (например, сегментный адрес) 
    ; использовать нельзя - процессор сгенерирует исключение общей защиты. Тем
    ; не менее, при переходе в защищённый режим регистр CS будет содержать 
    ; сегментный адрес, который использовался в режиме реальных адресов, 
    ; поэтому выполнение следующей команды, какой бы она ни была, должно было 
    ; бы привести к генерации процессором исключения. На самом деле этого не 
    ; происходит, так как эта команда не выбирается из памяти - она уже 
    ; находится в конвейере процессора (даже в таком процессоре, как i386, 
    ; есть конвейер) и поэтому вы можете выполнить эту команду.

    ; Команда дальнего перехода обязательно очистит конвейер 
    ; процессора и заставит его обратится к таблице GDT, выбрать оттуда 
    ; дескриптор, селектор которого указан в адресе команды и начать выборку 
    ; команд со смещения, также указанного в этом адресе. Это критический 
    ; момент в работе программы. Если в GDT, селекторе, смещении или самой 
    ; команде будет обнаружена ошибка, то процессор сгенерирует исключение, а 
    ; так как систему прерываний мы для него пока не определяли, то он 
    ; попросту зависнет либо произойдёт сброс - это уже зависит от "железа".

    ; Если вы не выполните первой команду дальнего перехода, а 
    ; другую, которая не изменит содержимое регистра CS (а это - все остальные
    ; команды), то процессор произведёт выборку в конвейер новой команды, 
    ; используя текущие значения CS:IP, а так как в CS содержится не селектор 
    ; (процессор уже в защищённом режиме!), то произойдёт исключение и 
    ; зависание.

    ; С регистрами данных ситуация обстоит хуже - DS можно не 
    ; инициализировать, но при работе через него вы получите совсем не те 
    ; данные, что должны были бы, а обращение к ES, отображённому на 
    ; видеопамять подвешивает процессор. 
    ; Load protected mode entry point into CS:EIP
    jmp far dword 0000000000001000b:pm_entry ; 0000000000001000b is a segment selector which is loaded into CS register
    ; Segment selector's format:
    ;  [0:1]  RPL              = 00b            - requested privilege level = 0 (most privileged)
    ;      2  TI               = 0              - chooses descriptor table; 0 means Global Descriptor Table
    ; [3:15]  Descriptor Index = 0000000000001b - index of descriptor inside the descriptor table = 1

; ========================================== PROTECTED MODE ====================================================
use32               ; generate 32-bit code
; Точка входа в код, уже работающий в защищенном режиме.
; Protected mode entry point
pm_entry:
    ; В регистр ax кладем селетор с индексом 2 (селектор номер 2 указывает в таблице дескрипторов на начало сегмента данных в защищенном режиме).
    ; Заносим этот селектор в остальные сегментные регистры: ds(Data segment), es(Extention segment) (оба сегмента отечают за данные), fs, gs - 
    ; дополнительные сегментные регистры, ss (Stack segment).
    ; Initialize segment registers (except CS which is already litialized)
    mov ax, 0000000000010000b ; segment selector: RPL = 0, TI = 0, Descriptor Index = 2
    mov ds, ax 
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax
    
    ; Здесь в регистр edi кладется адрес на начало видео памяти. Дальнейший код предназначен для вывода строки приветствия (происходит просто
    ; копирование символов и его атрибутов в видеопамять).
    mov edi, 0xB8000            ; 0xB8000 is the beginning of video-memory in 0x3 video-mode
    mov esi, message            ; the message which is going to be printed on the screen
    cld                         ; clear direction flag (DF is a flag used for string operations)

; Message-printing loop
.loop:                          
    lodsb                       ; load to al the next charachter located at [esi] address in memory (si is incremented automatically because the direction flag DF = 0)
    test al, al                 ; test al against zero
    jz .exit                    ; exit if al is zero
    stosb                       ; otherwise move al to memory at address [edi]
    mov al, 7                   ; 7 is the so-called attribute of the symbol
    stosb                       ; move al to memory at address [edi]
    jmp .loop

.exit:
    cli                         ; disable interrupts before halting the processor
    hlt                         ; halt the processor

message db 'Hello World!', 0

; ========================================= GLOBAL DESCRIPTOR TABLE ============================================
; Здесь самая важная секция программы, идет описание таблицы GDT состоящая из двух дескрипторов (кода и данных).
; Таблица будет выровнена по границе 8 байт для ускорения доступа к ней процессору.
align 8 ; we align global descriptor table to the 8-bytes boundary (for the sake of processor's performance)
gdt:
    ; Segment descriptor format
    ; BITS  | SIZE | FIELD
    ; ------+------+------
    ; 0-15  |  16  | Limit[0:15]
    ; 16-39 |  24  | Base[0:23]
    ; 40-47 |   8  | P DPL[0:1] S Type[0:3]
    ; 48-55 |   8  | G D/B L AVL Limit[16:19]
    ; 56-63 |   8  | Base[24:31]

; Поговорим о детальном устройстве адресации памяти в защищенном режиме: physical addres := logical addres(selector + offset)
;   Selector:  Состоит из 3 полей (Index, TI, RPL). Index является точкой входа (смещение в байтах от начала) в таблице, сожержащей инфу о 
; рассположени; и сегмента в физ. памяти и его атрибутах защиты. Каждая строка в таблице назыв. дескриптором. Таблицы две: глобавльная, содержащее 
; инфу для всех задач в системе, а так же локальная (каждый процесс может иметь свою локальную дескрипторную таблицу). TI определяет собственно на 
; какую таюлицу ссылается данный дескриптор в селекторном регистре (0 - локальная, 1 -глобавльная). В формировании логического адреса учавствуют 
; только Index и TI, RPL(Request Privileg Level) - запрашиваемый уровень привелегии используется только для защиты памяти (0 - самый высокий, 
; 3 - самый низкий). Размер сегментных регистров что в real mode, что в protected mode  равен 8 байт (16 бит): RPL [0 - 1], TI [2-2], Index [3 - 15] 
; биты соответственно. В итоге под RPL выделяется 2 бита, TI выделяется 1 бит, Index выделяется осташиеся 13 бит для указания индекса дескриптора в 
; таблице. Стоит отметить что у сегментный регистров есть и теневая часть используемая только процессором. Он используется для кэширования успешно
; запрошенных дескрипторов, т.е если при формировании адреса например CS:addres_some_variable, процессор посмотрит в содержимое CS возмет оттуда 
; значение индекса дескриптора в таблице и если запрашиваемый уровень привелегии данного сегмента процессу доступен, то дескриптор целиком 
; загрузиться в теневую часть сегментного регистра. Он используется что бы уменьшить количество запросов к таблице дескрипторов. Бывают и случай 
; когда весь процесс и часть выгружаются на диск ядром и затем могут повторно загрузаться в память, но уже скорее всго другого сегмента указывающего
; на другую физическую память, тогда придется обновить значение теневой части регистра сегментного.

; Descriptor: Дескриптор сегмента занимает 64 бита. Дескриптор состоит из трех основных частей: базового адреса сегмента, предела сегмента и прав 
; доступа с параметрами. В процессоре 80286 биты начиная с 48 и по 63 не используются и должны быть обнулены. Поле базового адреса выполняет роль, 
; аналогичную сегментной части адреса в R режиме, то есть определяет начало расположения сегмента в физической памяти. Для процессора 80286 база 
; занимает 24 бита. Для процессоров начиная с 80386 - 32 бита. 
; 
; Поле (Limit) предела определяет размер сегмента. Если смещение в сегменте будет равно значению поля предела, или превысит его, то доступ будет 
; блокирован. Таким образом исключается случайный или намеренный выход за границы сегмента. Для процессора 80286 поле предела занимает 16 бит. 
; Для процессоров начиная с 80386 - 24 бита. 
; 
; Права доступа и параметры(Type):  000 	- 	сегмент данных, только чтение
;                                   001 	- 	сегмент данных, чтение/запись
;                                   010 	- 	сегмент стека, только чтение (не используется)
;                                   011 	- 	сегмент стека, чтение/запись
;                                   100 	- 	сегмент кода, только выполнение
;                                   101 	- 	сегмент кода, чтение/выполнение
;                                   110 	- 	подчиненный сегмент кода, только выполнение
;                                   111 	- 	подчиненный сегмент кода, чтение/выполнение 
;
; Поле S. Содержит 1 для сегментов памяти и 0 для системных объектов. Системный объект может являться, а может и не являться, сегментом памяти. 
; Например, поле TYPE=001, если S=1, то это дескриптор сегмента данных с разрешенными записью и считыванием, а если S=0, то это дескриптор локальной
; таблицы дескрипторов LDT.
; 
; Поле DPL. Содержит уровень привилегий дескриптора. Именно с ним и сравнивается поле RPL(селектора в сегментном регистре) при попытке получить 
; доступ к памяти. Если уровень RPL выше чем в DPL (Descriptor Privileg Level) то будет сгенерированно исклбчения ошибка доступа к памяти и будет
; по идее вызван обработчик исклбчения, который снимет данный процесс с исполнения.
;
; Поле G. Описывает так называемую гранулярность сегмента. Влияет на интерпретацию поля предела. Если G=0, то сегмент имеет байтную гранулярность, то
; есть поле предела задает размер сегмента в байтах. Если G=1, то сегмент имеет страничную гранулярность, то есть поле предела задает размер 
; сегмента в страницах по 4К байт. Подробности страничной адресации будут рассмотрены чуть позже. Обратите внимание, процессор 80286 не имеет этого 
; поля в дескрипторе. 
;
; Поле D. Задает разрядность сегмента. Если D=0, то сегмент содержит 16 разрядные данные. Если D=1, то сегмент соержит 32 разрядные данные. 
; Собственно это поле определяет совместимость P режимов процессоров старших моделей с V режимом процессора 80286.
;
; Поле P. Бит присутствия. Помогает операционной системе организовать виртуальную память. Если P=0, то при обращении к сегменту возникает прерывание.; Таким образом, операционной системе достаточно выгрузить сегмент на диск и установить P=0 в дескрипторе, сам дескриптор уничтожать не требуется. 
; При обращении к сегменту находящемуся на диске, операционная система загружает его, возможно по другому физическому адресу, корректирует поле 
; базового адреса и устанавливает P=1. После чего задача может продолжить выполнение, даже не подозревая о происшедшем. 
;
; Поле A. Бит обращения. Так же помогает операционной системе организовать виртуальную память. Процессор устанавливает этот бит при обращении к 
; сегменту, описываемому данным дескриптором. Операционная система может периодически сбрасывать этот бит, а при нехватке памяти выгружать на диск 
; те сегменты, для которых не было обращения, то есть этот бит остался 0.
;
; Поле U. Пользовательский бит. Может использоваться системными программистами и операционными системами по своему усмотрению.
;
; Поле X. Зарезервировано фирмой Intel и должно быть 0.


; Первый дескриптор всегда должен быть нолувым(не используется) и при обращении к нему процессов всегда генерирует исключение.
NULL_SEG_DESCRIPTOR db 8 dup(0)

; Описание дескриптора сегмента кода   
CODE_SEG_DESCRIPTOR:
    dw 0xFFFF           ; Limit[0:15]
    db 0x00, 0x00, 0x00 ; Base[0:23]
    db 10011010b        ; P DPL[0:1] S Type[0:3]
    db 11001111b        ; G D/B L AVL Limit[16:19]
    db 0x00             ; Base[24:31]

    ; Detailed description of the segment descriptor:
    ; Base  = 0x00000000 - segment base address = 0
    ; Limit = 0xFFFFF    - segment size = 2^20
    ; P     = 1          - presence: segment is present in physical memory
    ; DPL   = 00b        - descriptor privilege level = 0 (most privileged)
    ; S     = 1          - system (TSS segment): segment is not a system segment
    ; Type  = 1010b      - code segment (1), C=0 R=1 A=0 execution and reading allowed
    ; G     = 1          - granularity: the size of the segment is measured in 4 kilobyte pages, i. e. it's equal to 2^20*4 KiB = 4 GiB
    ; D/B   = 1          - default size: operands and addresses are 32-bit wide
    ; L     = 0          - 64-bit code segment: in protected mode this bit is always zero
    ; AVL   = 0          - available: it's up to the programmer how to use this bit

; Описание дескриптора сегмента данных
DATA_SEG_DESCRIPTOR:
    dw 0xFFFF           ; Limit[0:15]
    db 0x00, 0x00, 0x00 ; Base[0:23]
    db 10010010b        ; P DPL[0:1] S Type[0:3]
    db 11001111b        ; G D/B L AVL Limit[16:19]
    db 0x00             ; Base[24:31]

    ; Detailed description of the segment descriptor:
    ; Base  = 0x00000000 - segment base address = 0
    ; Limit = 0xFFFFF    - segment size = 2^20
    ; P     = 1          - presence: segment is present in physical memory
    ; DPL   = 00b        - descriptor privilege level = 0 (most privileged)
    ; S     = 1          - system (TSS segment): segment is not a system segment
    ; Type  = 0010b      - data segment (0), E=0 W=1 A=0 reading and writing are allowed, expand-up data segment (offset ranges from 0 to Limit)
    ; G     = 1          - granularity: the size of the segment is measured in 4 kilobyte pages, i. e. it's equal to 2^20*4 KiB = 4 GiB
    ; D/B   = 1          - default size: stack pointer is 32-bit wide (concerns stack segment) and the upper bound of the segment is 4 GiB (concerns data segment)
    ; L     = 0          - 64-bit code segment: in protected mode this bit is always zero
    ; AVL   = 0          - available: it's up to the programmer how to use this bit

; Вычисляем размер таблицы дескрипторов: текущий адрсе ($) - адрес начала дескрипторной таблицы(gdt) = размер (разница в адресах).
gdt_size equ $ - gdt

; GDT  используется процессором всё время, пока он находится в защищённом режиме. Параметры GDT хранятся в специальном 48-разрядном регистре GDTR
; Формат регистра GDTR следующий:биты: 	 [0-15]: 16-разрядный предел GDT (размер таблицы), [15-47]: 32-разрядный адрес начала GDT 
; Адрес начала GDT - это тот адрес, по которому вы разместили GDT. Предел таблицы GDT - это максимальное смещение относительно её начала. 
; data to be loaded to GDTR register
gdtr:
    dw gdt_size - 1         ; 16-bit limit of the global descriptor table
    dd gdt                  ; 32-bit base address of the global descriptor table

; ======================================== BOOT SECTOR SIGNATURE ===============================================
finish:
    ; The size of a disk sector is 512 bytes. Boot sector signature occupies the two last bytes.
    ; The gap between the end of the source code and the boot sector signature is filled with zeroes.
    times 510-finish+start db 0
    db 55h, 0AAh    ; boot sector signature
